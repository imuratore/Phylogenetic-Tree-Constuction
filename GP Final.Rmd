---
title: "An Intro to Phylogenetic Tree Construction in R"
author: "Brandon Güell, Dani Antos, Isabella Muratore"
date: "11/7/2017"
output: 
  html_document:
    toc: true
    toc_float: true
---

# Preliminaries:
To begin, please start by installing the following packages and their dependents using the code below:

* install.packages("adegenet", dep=TRUE)
* install.packages("phangorn", dep=TRUE)

Make sure to load the following packages which we will use throughout the module:

* {stats} - super cool dope rad common statistical analysis package 
* {ade4} - awesome functions to analyse ecological/environmental data in "Euclidean Exploratory" framework
* {ape} - not as in primate, as in analysis & computation of phylo trees from DNA sequences
* {adegenet} - package for multivariate analysis of genetic markers data
* {phangorn} - phylo whaaaa? phylogenetic analysis package!


# Objectives

> In this module, we will learn about phylogenetic trees and how to recontruct them using three different methods in R. We will download and manipulate a small data set on seasonal influenza isolate samples in the US from 1993-2008. We will describe and show examples of how each of these approaches work and how to interpret and visualize the results for each using different aspects of phylo tree aesthetics.


# Introduction
Phylogenetic (phylo) trees..."I think"

![](https://i.stack.imgur.com/ahJk5.jpg)

Phylogenetic trees are useful diagrams which show inferred evolutionary relationships of a set of organisms, or a set of traits within a group of organisms. Phylogenetic tree reconstructions are made from analysis of observed heritable traits, commonly DNA sequences, previously morphological characters, in order to estimate common ancestors between taxa and sometimes times of divergence. Trees can represent evolutionary divergence according to information from entire genomes, or from one gene or a set of genes. Commonly, the so-called DNA barcode, part of the sequence for the highly conserved cytochrome oxidase subunit one has been single-handedly used to construct trees. This electron transport chain component is useful because very few mutations persist in fit organisms, so those that stick are very solid predictors of differences between lineages. 

Almost all phylogenetics methods start with a distance matrix in which differences between taxa are estimated by summing discrepancies in nucleotides or quantified morphological characters:

![A distance matrix](http://rosalind.info/media/distance_based_phylogeny.png)

This matrix is the direct basis for the simplest kind of tree, called UPGMA, or unweighted pair group method using arithmetic mean. Another form of simple tree building is called neighbor joining and is considered more reliable. Neighbor joining mehtods produce unrooted trees unless you take further steps to root the tree, while UPGMA produced a rooted tree. Perhaps the most important difference between these two is that UPGMA assumes a constant rate of evolution AKA nucleotide substitution everywhere and over time. Neighbor joining does not make this assumption. 

When phylogenetics first came into vogue, most scientists used small sets of morphological features to predict the relationships between small groups of organisms and most of them built Bayesian trees, based upon Bayes' Theorem. 

However as biological observations became more complex, most people switched over to "frequentist" methods, such as parsimony, due to the large amount of computational power that would be required to resolve Bayesian phylogenies for larger data sets. 

Towards the latter half of the 20th century, most biologist began to agree that Bayesian methods created more realistic trees, due to their relative resistance to problems such as long-branch attraction, among other issues. The advent of computing technology once again made these methods feasible. However, many scientists bitterly resisted this transition, resulting in intellectual conflicts. 

### Nerd Drama

One such conflict has been called ["Parsimony-gate"](https://www.wired.com/2016/02/twitter-nerd-fight-reveals-a-long-bizarre-scientific-feud/). This involved the traditionalist editors of the well-known journal "Cladistics" publishing an editorial discouraging the use of Bayesian methods in journal submissions when parsimony could be used. Subsequently, many biologists criticized the article on twitter, only to receive aggressive responses from the original author. 

*****

## Types of phylo trees {.tabset}
### Rooted
Rooted phylo trees imply relationships about the most recent common ancestor. This information is given by showing an "outgroup" which is the most basal extant ancestor in a given tree. Each node thus represents the most recent common ancestor for each set of taxa which meet at that node.
![](https://www.ncbi.nlm.nih.gov/Class/NAWBIS/Modules/Phylogenetics/images/phylo1003.gif)

### Unrooted
Unrooted phylo trees are similar to rooted trees in that each node represents the most recent common ancestor between groups. However, it differs because the unrooted tree does not give information or imply any ancentral "root" or basal outgroup.
![](https://www.ncbi.nlm.nih.gov/Class/NAWBIS/Modules/Phylogenetics/images/phylo1002.gif)

### Tree Drawing Styles
Phylo trees can also be drawn differently. The trees below all show the same relationships between the taxa, just in different aesthetically pleasing ways.
![](http://ksuweb.kennesaw.edu/~jdirnber/InvertZoo/LecIntro/trees2.jpg)


## Three methods for phylo tree reconstruction discussed here:{.tabset}

### Distance-based
Distance based phylogenetic trees are pretty much exactly what they sound like: we find the "genetic distance" between pairs of taxa and cluster the species using the distances. Pairs with shorter distances are clustered more closely together than pairs with large distances. Because making distance-based trees is usually requires an algorithm to compute the pairwise distances, the trees produced can be rooted or unrooted depending on the algorithm used (we'll go into this a litter later). **Advantages** of this method? It's fast and flexible. **Disadvantages**? The tree produced can change based on the algorithm we choose, and we can't test to make sure that we're using the best model, so the tree can be inaccurate.

### Maximum parsimony
Maximum parisomy phylo trees aim to minimize the number of character-state changes in a tree. Thus, this usually produces the simplest possible trees with the least amount of branches (i.e. character-state changes). The method is composed of 1) initiating an algorithm using a tree and 2) making small changes to the tree by simplifying relationships until we are left with the most parsimonious tree and no futher simplifications can be made.

### Likelihood-based
    explanation...
    FIGURES

*****

# Useful skills we will go over today:
* Importing data on DNA sequences in a phylogenetic tree format
* Phylogenetic tree reconstruction using various methods in R
* Plotting and interpret results from trees constructed
* Test for molecular clock and estimates rates of evolution
* Use bootstrapping for examining tree topology/organization reliability

*****
*****
*****

# Read in the DNA sequences of seasonal influenza (H3N2)
This data can be downloaded from Genbank [here](http://www.ncbi.nlm.nih.gov/genbank/). The data is organized into two files: 1) the [DNA sequences](http://adegenet.r-forge.r-project.org/files/usflu.fasta) and 2) the [annotations](http://adegenet.r-forge.r-project.org/files/usflu.annot.
csv). We'll start by loading the DNA sequences data using the function fasta2DNAbin() from the adegenet package. Let's name this datafram dna. We can call this dataframe and see that it is organized in a matrix in binary format and contains 80 DNA sequences...
```{r}
library(adegenet)
dna <- fasta2DNAbin(file="http://adegenet.r-forge.r-project.org/files/usflu.fasta")
dna
```

We can read in the annotation file in R using the following code:
```{r}
annot <- read.csv("http://adegenet.r-forge.r-project.org/files/usflu.annot.csv", header=TRUE, row.names=1)
```


# Distance-based methods

# Maximum parsimony

> Note: if you haven't already, make sure to install the package "phangorn". 

To use the maximum parsimony phylo tree reconstruction methods, we will need a tree in "ape"'s format: as a phylo object and the original DNA data sequences in a format from the "phangorn" package: phyDat. Let's begin!

```{r}
library(phangorn)
dna2 <- as.phyDat(dna) #assign the original dna sequences data as a phyDat object...
class(dna2) #ensure that new dataframe "dna2" is in phyDat format
dna2
```

Next, we will reconstruct a tree using the nj() function as we saw before.
```{r}
tre.ini <- nj(dist.dna(dna,model="raw"))
tre.ini
```

We can then measure this tree's parsimony using the function parsimony() from the "phangorn" package.
```{r}
?parsimony()
parsimony(tre.ini, dna2)
```

Lastly, the function which which will algorithmically make our tree the most parsimonious possible is the otim.parsimony() function. Lets use it below on our newly reconstructed tree and see what happens.
```{r}
tre.pars <- optim.parsimony(tre.ini, dna2)
tre.pars

parsimony(tre.pars, dna2)
```
The result is a very similar tree to the one before, but its final "p-score" is 2 values lower than before. Thus, although not by much, this newly made "tre.pars" phylo tree is our most parsimonious tree.
Again, we can plot this tree similarly as before:
```{r}
myPal <- colorRampPalette(c("red","yellow","green","blue"))

library(ape)
plot(tre.pars, type="unr", show.tip=FALSE, edge.width=2)
title("Maximum-parsimony tree")
tiplabels(tre.pars$tip.label, bg=transp(num2col(annot$year, col.pal=myPal),.7), cex=.5, fg="transparent")
temp <- pretty(1993:2008, 5)
legend("bottomright", fill=transp(num2col(temp, col.pal=myPal),.7), leg=temp, ncol=2, bg=transp("white"))
```
Again, our tree is unrooted and has no branch lengths. We can likely attribute the similarity in results in our parsimonious tree to the other methods we used before to the fact that there is little divergence between the sequences in our data.

# Maximum Likelihood-based

Maximum likelihood is considered a type of likelihood based tree construction, a group to which Bayesian methods also belong. Maximum likelihood maximizes the chances of collecting the data set in question given that the calculated tree, along with parameters describing evolutionary rules, are true. Mathematically this is represented as:

P(D|M)

Where P = probability, D = observed data, and M = model

A common way of understanding this approach is to use an observed set of coin flips to say whether this outcome is more likely under the model that the coin is fair, or that it is biased. 

Let's prepare to build a maximum likelihood tree.

This function takes a vector of color labels and makes them applicable to groups on a tree
```{r}
myPal <- colorRampPalette(c("red","yellow","green","blue"))
```
Loading DNA sequences for a set of different influenza strains collected from 1993 to 2008 in the US (get your flu shot every year!)

FASTA is a universally used sequence file format that is here converted to the format used by the phangorn package
```{r}
dna <- fasta2DNAbin(file="http://adegenet.r-forge.r-project.org/files/usflu.fasta")
```
Loading annotations to mark the identity of the sequences
```{r}
annot <- read.csv("http://adegenet.r-forge.r-project.org/files/usflu.annot.csv", header=TRUE, row.names=1)
```
First, we build a simple neighbor-joining tree that we can hand to the ape package in order to turn it into maximum likelihood

The genetic distances between flu strains are here calculated using a model published by Tamura and Nei (1993). This model says that transitions (purine to purine or pyrimidine to pyrimidine) and transversions (purine to pyrimidine or vice versa) may happen at different rates, that not every nucleotide appears at the same frequency, and that the rate of substitution can vary between different regions of the sequence. Alternatives to this model include the Jukes-Cantor model in which all types of nucleotide substitutions are equally probable. 
```{r}
tre.ini <- nj(dist.dna(dna,model="TN93"))
```
pml calculates the likelihood of the data given the model, initially just using our neighbor joining tree
```{r}
pml(tre.ini, dna2, k=4)
```
The above calculation has failed since the loglikelihood is listed as NaN. This is likely caused by missing sequence data

Using table we can look at the number of occurences of the difference bases according to their [IUPAC ambiguity codes](http://www.dnabaser.com/articles/IUPAC%20ambiguity%20codes.html). In a typical fasta file, bases that could not be sequenced accurately are listed as "N" and a number of other letters can indicate a lesser degree of uncertainty such as "Y" to indicate that the base must be a pyramidine, etc. 
```{r}
table(as.character(dna2))
```
Since we think there is a problem with missing bases, we search for any bases that are not listed as A, T, G, or C
```{r}
na.posi <- which(apply(as.character(dna),2, function(e) any(!e %in% c("a","t","g","c"))))
```
Due to the nature of sequencing techniques, sometimes sequences have poorer quality in a particular area such as the very beginning or very end. Therefore, we will plot the frequence of non-ATCG bases over their position in the sequence. 
```{r}
temp <- apply(as.character(dna),2, function(e) sum(!e %in% c("a","t","g","c")))
plot(temp, type="l", col="blue", xlab="Position in HA segment", ylab="Number of NAs")
```
Due to the majority of the missing data appearing in the start of the sequence, we can infer that this was caused to differences in overall length between strains due to sequence divergence (AKA your flu shot from 2 years ago will not work!!)

We can exclude the missing data
```{r}
dna3 <- dna[,-na.posi]
```
Now it looks complete
```{r}
table(as.character(dna3))
```
Now we can convert back to phangorn format
```{r}
dna4 <- as.phyDat(dna3)
```
We can make the NJ tree again, and use pml again to calculate likelihood
```{r}
tre.ini <- nj(dist.dna(dna3,model="TN93"))
fit.ini <- pml(tre.ini, dna4, k=4)
fit.ini
```
Now we can optimize the tree, using options to also optimize tree topology (optNni), base frequencies (optBf), and substitution rates (optQ). We will use a gamma distribution (optGamma) for variation in substitution rates at different sites in the sequence
```{r}
fit <- optim.pml(fit.ini, optNni=TRUE, optBf=TRUE, optQ=TRUE, optGamma=TRUE)
fit
```
Let's compare the optimized tree to the neighbor joining tree using an anova. 
```{r}
anova(fit.ini, fit)
```
The anova shows a significant difference between the two trees. We can use the AIC, as discussed in previous modules, to see which is better.
```{r}
AIC(fit.ini)

AIC(fit)
```
Since a lower AIC value is better, we can see that the optimized tree worked better than the neighbor joining tree. 

Now we plot the tree using the same method as before
```{r}
tre4 <- root(fit$tree,1)
tre4 <- ladderize(tre4)
plot(tre4, show.tip=FALSE, edge.width=2)
title("Maximum-likelihood tree")
tiplabels(annot$year, bg=transp(num2col(annot$year, col.pal=myPal),.7), cex=.5, fg="transparent")
axisPhylo()
temp <- pretty(1993:2008, 5)
legend("topright", fill=transp(num2col(temp, col.pal=myPal),.7), leg=temp, ncol=2)

```


*****

# Additional Resources and Useful Links
* [Introduction to phylogenetics using R](http://adegenet.r-forge.r-project.org/files/MSc-intro-phylo.1.1.pdf)
* [Phylogenetic trees in R: Lars Schmitz](http://schmitzlab.info/phylo.html)
* [Data wrangling cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
* [Rmarkdown cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf)

*****

# Citations
1. S. Dray and A.-B. Dufour. The ade4 package: implementing the duality diagram
for ecologists. Journal of Statistical Software, 22(4):1–20, 2007.
2. T. Jombart. adegenet: a R package for the multivariate analysis of genetic
markers. Bioinformatics, 24:1403–1405, 2008.
3. T. Jombart and I. Ahmed. adegenet 1.3-1: new tools for the analysis of genomewide
snp data. Bioinformatics, 27:3070–3071, 2011.
4. Scot A Kelchner and Michael A Thomas. Model use in phylogenetics: nine key
questions. Trends Ecol Evol, 22(2):87–94, Feb 2007.
5. E. Paradis, J. Claude, and K. Strimmer. APE: analyses of phylogenetics and
evolution in R language. Bioinformatics, 20:289–290, 2004.
6. R Development Core Team. R: A Language and Environment for Statistical
Computing. R Foundation for Statistical Computing, Vienna, Austria, 2011.
ISBN 3-900051-07-0.
7. Klaus Peter Schliep. phangorn: phylogenetic analysis in r. Bioinformatics,
27(4):592–593, Feb 2011.
8. K. Tamura and M. Nei. Estimation of the number of nucleotide substitutions in
the control region of mitochondrial dna in humans and chimpanzees. Mol Biol
Evol, 10(3):512–526, May 1993.